* Packages
This part needs to be first. If there are any files missing, then
this will make sure that they are installed.

#+begin_src emacs-lisp
  ;;; automatically install packages
  (require 'package)
  (setq davorb-packages
        '(gnu-apl-mode
          ace-jump-mode
          ack
          afternoon-theme
          color-theme
          column-marker
          darkroom
          dockerfile-mode
          expand-region
          geiser
          github-browse-file
          glsl-mode
          helm
          helm-ack
          highlight-sexp
          highlight-symbol
          js2-mode
          js2-refactor
          leuven-theme
          markdown-mode
          material-theme
          multiple-cursors
          nodejs-repl
          notify
          org-journal
          paredit
          rainbow-delimiters
          sass-mode
          undo-tree
          wc-mode
          yaml-mode))

  (package-initialize)

  (defun install-packages (packages)
    (let ((not-installed (remove-if 'package-installed-p packages)))
      (if not-installed
          (if (y-or-n-p (format "there are %d packages to be installed. install them? "
                                (length not-installed)))
              (progn (package-refresh-contents)
                     (dolist (package not-installed)
                       (package-install package)))))))

  (install-packages davorb-packages)
#+end_src

* Initialization
#+begin_src emacs-lisp
  (require 'helm-config)
  (helm-mode 1)
  (helm-adaptive-mode 1)
  (helm-autoresize-mode 1)

  (require 'color-theme)
  (color-theme-initialize)

  (autoload
    'ace-jump-mode
    "ace-jump-mode"
    "Emacs quickmove minor mode"
    t)

  (require 'expand-region)
  (require 'highlight-symbol)
  (require 'js2-refactor)
  (require 'nodejs-repl)
  (require 'org-journal)
  (require 'darkroom)
  (require 'wc-mode)
  (require 'notify)

  (require 'undo-tree)
  (global-undo-tree-mode 1)

  (require 'column-marker)
#+end_src
** Lisp
#+BEGIN_SRC emacs-lisp
  (require 'paredit)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)

  ;(add-hook 'slime-repl-mode-hook (lambda () (paredit-mode +1)))

  (require 'eldoc)
  (eldoc-add-command
   'paredit-backward-delete
   'paredit-close-round)
#+END_SRC

* Custom functions
** insert-current-date
#+begin_src emacs-lisp
(defun insert-current-date () (interactive)
       (insert (shell-command-to-string "echo -n $(date +%Y-%m-%d)")))
#+end_src
** increment-number-at-point
#+begin_src emacs-lisp
(defun increment-number-at-point ()
  (interactive)
  (skip-chars-backward "0123456789")
  (or (looking-at "[0123456789]+")
      (error "No number at point"))
  (replace-match (number-to-string (1+ (string-to-number
                                               (match-string 0))))))
#+end_src
** add-to-multiple-hooks
Take a mode and add it to multiple hooks.
#+begin_src emacs-lisp
(defun add-to-multiple-hooks (function hooks)
  (mapc (lambda (hook)
    (add-hook hook function)) hooks))
#+end_src
** find-user-init-file
#+begin_src emacs-lisp
  (defun find-user-init-file ()
    "Edit your .emacs file instantly."
    (interactive)
    (find-file user-init-file))
#+end_src
** indent-buffer
#+BEGIN_SRC emacs-lisp
  (defun indent-buffer ()
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max) nil)))
#+END_SRC

** unfill-paragraph
#+BEGIN_SRC emacs-lisp
  ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
  ;;; Takes a multi-line paragraph and makes it into a single line of text.
  (defun unfill-paragraph ()
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))
#+END_SRC

** solarized-toggle
   Switch between dark and light modes when using the ~solarized~
   theme.

#+BEGIN_SRC emacs-lisp
  (defun solarized-toggle ()
    "Switch between dark and light modes for the solarized theme"
    (interactive)
    (let ((current (frame-parameter nil 'background-mode)))
      (cl-flet ((change-to (x)
                           (disable-theme 'solarized)
                           (set-frame-parameter nil 'background-mode x)
                           (load-theme 'solarized t)))
        (cond ((eq current 'light) (change-to 'dark))
              ((eq current 'dark) (change-to 'light))))))
#+END_SRC

** open-in-browser
#+BEGIN_SRC emacs-lisp
  (defun open-in-browser ()
    "Opens the current file with the default browser"
    (interactive)
    (if (buffer-file-name)
        (shell-command (concat "xdg-open \"file://"
                               (buffer-file-name)
                               "\""))))
#+END_SRC
** name-current-mode
   Returns the name of the major mode in the current buffer.

#+BEGIN_SRC emacs-lisp
  (defun current-mode-name (&optional buffer-or-string)
    "Returns the major mode associated with a buffer"
    (interactive)
    (message (symbol-name (buffer-local-value
                           'major-mode
                           (if buffer-or-string
                               (get-buffer buffer-or-string)
                             (current-buffer))))))
#+END_SRC

* Starter-kit
** Yasnippet
#+begin_src emacs-lisp
  (starter-kit-load "yasnippet")
#+end_src

** LaTeX
#+begin_src emacs-lisp
  (starter-kit-load "latex")
#+end_src

** bindings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-h") 'backward-kill-word)

  ;; align code in pretty way
  (global-set-key (kbd "C-x \\") 'align-regexp)
#+end_src

* Programming modes
** List of lisp modes
#+begin_src emacs-lisp
  (defvar *lisp-hooks*
    '(
      eval-expression-minibuffer-setup-hook
      racket-mode-hook
      clojure-mode-hook
      common-lisp-mode-hook
      geiser-mode-hook
      geiser-repl-mode-hook
      ielm-mode-hook
      lisp-interaction-mode-hook
      lisp-mode-hook
      scheme-mode-hook
      slime-mode-hook
  emacs-lisp-mode-hook
      ))
#+end_src
** List of programming modes
#+begin_src emacs-lisp
  (defvar *programming-hooks*
    (append
     ,*lisp-hooks*
     '(ruby-mode-hook
       js2-mode-hook
       js-mode-hook
       c-mode-hook
       shell-script-mode-hook
       c++-mode-hook
       html-mode-hook
       css-mode-hook
       haskell-mode-hook
       java-mode-hook)))
#+end_src
** Programming in general
#+begin_src emacs-lisp
  (require 'highlight-symbol)

  (add-to-multiple-hooks #'(lambda ()
                             (interactive)
                             (column-marker-1 80))
                         ,*programming-hooks*)
#+end_src
** Git
#+begin_src emacs-lisp
(setq magit-last-seen-setup-instructions "1.4.0")
#+end_src

   Disable emacs' built in =vc= package for performance reasons,
   because I don't use it anyway.
#+BEGIN_SRC emacs-lisp
  (setq vc-handled-backends nil)
#+END_SRC
** JavaScript
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js2-jsx-mode))
  (eval-after-load "js2-mode"
    '(progn
       (setq js2-missing-semi-one-line-override t)
       (setq-default js2-basic-offset 2)))
  (setq js2-highlight-level 3)

  (add-hook 'js2-mode-hook #'js2-refactor-mode)
  (add-hook 'js2-mode-hook #'electric-indent-mode)
  (add-hook 'js2-mode-hook #'electric-pair-mode)

  (font-lock-add-keywords 'espresso-mode
                          '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
                             1 font-lock-warning-face t)))
  (defun pretty-print-json ()
    "Pretty-print the json object following point."
    (interactive)
    (require 'json)
    (let ((json-object (save-excursion (json-read))))
      (switch-to-buffer "*json*")
      (delete-region (point-min) (point-max))
      (insert (pp json-object))
      (goto-char (point-min))))
#+end_src

** CSS
#+BEGIN_SRC emacs-lisp
  (setq css-indent-offset 2)
#+END_SRC
** SASS
#+begin_src emacs-lisp
(setq-default scss-compile-at-save nil)
(add-to-list 'auto-mode-alist '("\\.scss\\'" . sass-mode))
#+end_src
** Lisp
#+BEGIN_SRC emacs-lisp
  (add-to-multiple-hooks 'rainbow-delimiters-mode *lisp-hooks*)
  (add-to-multiple-hooks 'enable-paredit-mode *lisp-hooks*)
  ;(add-to-multiple-hooks 'highlight-sexp-mode *lisp-hooks*)

  (setf geiser-repl-mode-hook '(enable-paredit-mode))
  (setf geiser-mode-hook '(enable-paredit-mode))
#+END_SRC
*** Scheme
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook #'geiser-mode)
#+END_SRC
** Clojure
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-mode-hook #'eldoc-mode)

  ;; C-z for repl
  (setq cider-repl-display-in-current-window t)
#+END_SRC

** C
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook #'electric-indent-mode)
  (add-hook 'c-mode-hook #'electric-pair-mode)

  (setq-default c-basic-offset 4 c-default-style "linux")
  (setq-default tab-width 4 indent-tabs-mode t)
  (define-key c-mode-base-map (kbd "RET") 'newline-and-indent)
#+END_SRC
** Haskell
   =C-c h= will Hoogle the identifier at point.

#+BEGIN_SRC emacs-lisp
  (require 'haskell-mode)
  (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
#+END_SRC
** APL
*** gnu-apl-mode
	Change the default input method.

#+BEGIN_SRC emacs-lisp
  (add-to-multiple-hooks
   (lambda () (set-input-method "APL-Z"))
   '(gnu-apl-interactive-mode-hook
     gnu-apl-mode-hook))
#+END_SRC

	Hide the keyboard on startup.
#+BEGIN_SRC emacs-lisp
  (setf gnu-apl-show-keymap-on-startup nil)
#+END_SRC

	Dont' show tips on start.
#+BEGIN_SRC emacs-lisp
  (setq gnu-apl-show-tips-on-start nil)
#+END_SRC

* Look 'n feel
#+begin_src emacs-lisp
  (menu-bar-mode 1)
  (tool-bar-mode 0)

  ;; Fontify the whole line for headings (with a background color).
  (setq org-fontify-whole-heading-line t)
#+end_src
* Settings
** Backups
#+begin_src emacs-lisp
  ;(let ((temporary-file-directory "~/.saves"))
  (setq backup-directory-alist
        '(("." . "~/.saves")))
  ;  (setq auto-save-file-name-transforms
  ;        `((".*" ,temporary-file-directory t))))
  (setq delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
  (setq backup-by-copying t) ; safest, but slowest
#+end_src
** Remove trailing whitespace
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Highlight
*** interactive highlighting
    C-x w . --- highlight word

    M-s h .

    C-w w r --- unhighlight regexp

    M-s h u
#+begin_src emacs-lisp
  (global-hi-lock-mode 1)
#+end_src
*** Highlight symbols
#+begin_src emacs-lisp
  (add-hook 'highlight-symbol-mode js2-mode-hook)
#+end_src
** Dired
   Hide hidden files. You can toggle =dired-omit-mode= with C-x M-o.
#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (setq dired-omit-files "^\\...+$")
  (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
#+END_SRC

** Spelling
*** org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'flyspell-mode)
#+END_SRC
* Keybindings
** General
*** ace-jump-mode
"C-c SPC" ==> ace-jump-word-mode
"C-u C-c SPC" ==> ace-jump-char-mode
"C-u C-u C-c SPC" ==> ace-jump-line-mode
#+begin_src emacs-lisp
(define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
#+end_src
*** expand-region
Binding: C-=
#+begin_src emacs-lisp
(global-set-key (kbd "C-=") 'er/expand-region)
#+end_src
*** electic-buffer-list
#+begin_src emacs-lisp
(global-set-key [f12] 'buffer-menu)
#+end_src
*** helm
#+begin_src emacs-lisp
(global-set-key (kbd "M-x") 'undefined)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x f") 'helm-find-files)
(global-set-key (kbd "C-x b") 'helm-buffers-list)

;(global-set-key (kbd "C-c <SPC>") 'helm-all-mark-rings)
(global-set-key (kbd "C-x r b") 'helm-filtered-bookmarks)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-,") 'helm-calcul-expression)
#+end_src
*** increment number
#+begin_src emacs-lisp
(global-set-key (kbd "C-c i") 'increment-number-at-point)
#+end_src
*** undo-tree
#+BEGIN_SRC emacs-lisp
  (defalias 'redo 'undo-tree-redo)

  (global-set-key (kbd "C-z") 'undo)
  (global-set-key (kbd "C-M-z")'undo-tree-visualize)
  (global-set-key (kbd "C-S-z") 'redo) ; mac style redo
#+END_SRC

*** window resize
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "S-C-<down>") 'shrink-window)
  (global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+END_SRC
*** multiple-cursors
	The keybindings for this are:

	- =C->= marks next like this
	- =C-<= marks previous like this
	- =C-c C-<= marks ~all~ like this.

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC

** Programming
*** indent-buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c M-/") 'indent-buffer)
#+END_SRC

*** JavaScript
**** js2-refactor-mode
     extract function with *C-c C-x ef*

     1) `ef` is `extract-function`: Extracts the marked expressions out into a new named function.
     2) `em` is `extract-method`: Extracts the marked expressions out into a new named method in an object literal.
     3) `ip` is `introduce-parameter`: Changes the marked expression to a parameter in a local function.
     4) `lp` is `localize-parameter`: Changes a parameter to a local var in a local function.
     5) `eo` is `expand-object`: Converts a one line object literal to multiline.
     6) `co` is `contract-object`: Converts a multiline object literal to one line.
     7) `eu` is `expand-function`: Converts a one line function to multiline (expecting semicolons as statement delimiters).
     8) `cu` is `contract-function`: Converts a multiline function to one line (expecting semicolons as statement delimiters).
     9) `ea` is `expand-array`: Converts a one line array to multiline.
     10) `ca` is `contract-array`: Converts a multiline array to one line.
     11) `wi` is `wrap-buffer-in-iife`: Wraps the entire buffer in an immediately invoked function expression
     12) `ig` is `inject-global-in-iife`: Creates a shortcut for a marked global by injecting it in the wrapping immediately invoked function expression
     13) `ag` is `add-to-globals-annotation`: Creates a `/*global */` annotation if it is missing, and adds the var at point to it.
     14) `ev` is `extract-var`: Takes a marked expression and replaces it with a var.
     15) `iv` is `inline-var`: Replaces all instances of a variable with its initial value.
     16) `rv` is `rename-var`: Renames the variable on point and all occurrences in its lexical scope.
     17) `vt` is `var-to-this`: Changes local `var a` to be `this.a` instead.
     18) `ao` is `arguments-to-object`: Replaces arguments to a function call with an object literal of named arguments.
     19) `3i` is `ternary-to-if`: Converts ternary operator to if-statement.
     20) `sv` is `split-var-declaration`: Splits a `var` with multiple vars declared, into several `var` statements.
     21) `ss` is `split-string`: Splits a `string`.
     22) `uw` is `unwrap`: Replaces the parent statement with the selected region.
     23) `lt` is `log-this`: Adds a console.log() statement for what is at point (or region).
     24) `dt` is `debug-this`: Adds a debug() statement for what is at point (or region).
     25) `sl` is `forward-slurp`: Moves the next statement into current function, if-statement, for-loop or while-loop.
     26) `ba` is `forward-barf`: Moves the last child out of current function, if-statement, for-loop or while-loop.
     27) `k` is `kill`: Kills to the end of the line, but does not cross semantic boundaries.
    #+begin_src emacs-lisp
  (js2r-add-keybindings-with-prefix "C-c C-x")
#+end_src
*** Compile
#+begin_src emacs-lisp
(global-set-key [f9] 'compile)
#+end_src
*** magit
#+begin_src emacs-lisp
(global-set-key (kbd "C-x g") 'magit-status)
#+end_src

* Skeletons
** LaTeX
#+begin_src emacs-lisp
  (define-skeleton latex-skeleton
    "Inserts a begin_src-skeleton into the current buffer.
  This only makes sense for empty buffers."
    "\\documentclass[a4paper]{article}\n\n"
    "\\documentclass[a4paper]{article}\n"
    "\\usepackage[utf8]{inputenc}\n"
    "\\usepackage[swedish]{babel} % for Swedish characters\n\n"
    "\\usepackage{fancyvrb}       % for code listings\n"
    "\\fvset{tabsize=4}\n"
    "\\fvset{fontsize=\small}\n\n"
    "\\title{Document title}\n"
    "\\author{Davor Babi\'{c}}\n\n"
    "\\begin{document}\n"
    "\\maketitle\n\n"
    "\\end{document}\n")
#+end_src
* yasnippet
#+BEGIN_SRC emacs-lisp
  (setf yas-snippet-dirs "~/.emacs.d/snippets")
  (yas-reload-all)
#+END_SRC
